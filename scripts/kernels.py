#!/opt/local/bin/python2.7
from __future__ import division
from sympy import *
q, x = symbols('q x')

def getkernelfuncs(w,R):
    dw  = diff(w,q)
    d2w = diff(dw,q)
    c1D = sympify(1)/(2*integrate(w,(q,0,R)))
    c2D = sympify(1)/(integrate(2*pi*q*w,(q,0,R)))
    c3D = sympify(1)/(integrate(4*pi*q*q*w,(q,0,R)))
    var = integrate(q*q*w,(q,0,R))
    return (dw, d2w, c1D, c2D, c3D, dw, dw, dw)
    #
    #--force softening function
    #
    fsoft = piecewise_fold(4*pi*c3D*integrate(f*q*q,q)/q**2)
    farg = list(fsoft.args)
    lastarg = len(fsoft.args) - 1
    farg[lastarg] = (sympify(1)/q**2,fsoft.args[lastarg].cond)
    #
    #--work out the integration constant for the force softening
    #  by matching the different parts of the piecewise function
    #
    if isinstance(fsoft, Piecewise):
       for i, (e, c) in reversed(list(enumerate(fsoft.args))):
           if i < lastarg:
              (ep, cp) = farg[i+1]
              s = "%s" %c
              qval = sympify(s.split()[2])
              fe = simplify(e + qval**2*(ep.subs(q,qval) - e.subs(q,qval))/q**2)
              farg[i] = (fe,c)
    tuple(farg)
    fsoft = Piecewise(*farg)
    #
    #--potential function
    #
    pot = integrate(fsoft,q)
    #
    #--work out the integration constant for the potential
    #
    parg = list(pot.args)
    if isinstance(pot, Piecewise):
       for i, (e, c) in reversed(list(enumerate(pot.args))):
           if i < len(pot.args) - 1:
              (ep, cp) = parg[i+1]
              s = "%s" %c
              qval = s.split()[2]
              pote = simplify(e + (ep.subs(q,qval) - e.subs(q,qval)))
              parg[i] = (pote,c)
    tuple(parg)
    pot = Piecewise(*parg)
    #
    #--derivative of potential with respect to h
    #
    dpotdh = pot
    parg = list(pot.args)
    if isinstance(pot, Piecewise):
       for i, (e, c) in enumerate(pot.args):
           ep = simplify(-e - q*diff(e,q))
           parg[i] = (ep, c)
       tuple(parg)
       dpotdh = Piecewise(*parg)
    
    return (dw, d2w, c1D, c2D, c3D, fsoft, pot, dpotdh)

def printkernel(w,R):
    dw, d2w, c1D, c2D, c3D, fsoft, pot, dpotdh = getkernelfuncs(w,R)
    print "\nW:"
    print w
    print "\nFirst derivative:"
    print dw
    print "\n2nd derivative:"
    print d2w
    print "\n1D normalisation:"
    print c1D
    print "\n2D normalisation:"
    print c2D
    print "\n3D normalisation:"
    print c3D

# utility to format output of real numbers correctly for Fortran floating point
def fmt(e):
    import re
    s = "%s" %e
    # add decimal points to numbers, but not if powers like q**2 (or *2 with one digit)
    # note that \g<0> gives first matching argument in the regex
    # rules are: (not **n)(not 0.123)(match ab0123)
    s = re.sub("((?!\*\*\d+)(?!\D\D\d+\.)\D\D\d+)|((!?\*\d+)\D\d+)|(/\d+)|((?!^\.\d+)^\d+)|((?!^-\d+\.)^-\d+)","\g<0>.", s)
    #s = re.sub("((?!\*\*\d+)\D\D\d+)|((?!^\.\d+)^\d+)|((?!\*\d+)\D\d+)","\g<0>.", s)
    #s = re.sub("((?!\*\*\d+)\D\D\d+)|(^\d+)|((?!\*\d+)\D\d+)","\g<0>.", s)
    f = sympify(s)
    g = "%s" %simplify(f)
    # only return simplify-ed strings if no fully expanded floats 0.345242545..
    if re.search("(\.\d\d\d\d\d+)",g):
       return s
    else:
       return g

# extended version of above, replacing q**2 with q2, q**3 with q2*q etc.
# and getting rid of excess zeros after decimal point, e.g. 7.0000->7
def fmte(e):
    import re
    s = "%s" %fmt(e)
    f = sympify(s)
    g = "%s" %simplify(f)
    if len(g) <= len(s) + 1:
       s = g
    s = re.sub("q\*\*12","q6*q6", s)
    s = re.sub("q\*\*11","q6*q4*q", s)
    s = re.sub("q\*\*10","q6*q4", s)
    s = re.sub("q\*\*9","q8*q", s)
    s = re.sub("q\*\*8","q8", s)
    s = re.sub("q\*\*7","q6*q", s)
    s = re.sub("q\*\*6","q6", s)
    s = re.sub("q\*\*5","q4*q", s)
    s = re.sub("q\*\*4","q4", s)
    s = re.sub("q\*\*3","q2*q", s)
    s = re.sub("q\*\*2","q2", s)
    s = re.sub("q\*\*\(-2\.\)","1./q2",s)
    #s = re.sub("\.0+\D*",".", s)
    s = re.sub("q\*\*-2\.0","1./q2",s)
    return s

def wrapit(s,indent):
    if len(s) > 72:
       pos = s.rfind(" ", 6, 72)
       if pos == -1:
           pos = 72
       hunk = s[:pos]
       rest = s[pos:].lstrip()
       s = "%s &\n" %(hunk) + " "*indent
       while len(rest) > 0:
           pos = rest.rfind(" ", 0, 66)
           if pos == -1 or len(rest) < 66:
               pos = 66
           hunk = rest[:pos]
           rest = rest[pos:].lstrip()
           if len(rest) > 0:
              s = "%s%s &\n" %(s,hunk) + " "*indent
           else:
              s = "%s%s" % (s,hunk)
    return s

# wrappers for above routines, specific to output formats
def fmtp(e):
    s = "%s" %fmte(e)
    s = wrapit(s,17)
    return s

def fmtn(e):
    s = "%s" %fmte(e)
    s = wrapit(s,25)
    return s

def printkernel_ndspmhd(w,R,name):
    dw, d2w, c1D, c2D, c3D, fsoft, pot, dpotdh = getkernelfuncs(w,R)
    print "!"
    print "!--%s (auto-generated by kernels.py)" %name
    print "!"
    print "    kernellabel = '%s' \n" %name
    print "    radkern = %.1f" %(R)
    print "    radkern2 = radkern*radkern"
    print "    dq2table = radkern2/real(ikern)"
    print "    select case(ndim)"
    print "      case(1)"
    print "         cnormk = %s" %fmt(c1D)
    print "      case(2)"
    print "         cnormk = %s" %fmt(c2D)
    print "      case(3)"
    print "         cnormk = %s" %fmt(c3D)
    print "    end select"
    print "    do i=0,ikern"
    print "       q2 = i*dq2table"
    print "       q4 = q2*q2"
    print "       q6 = q4*q2"
    print "       q8 = q4*q4"
    print "       q = sqrt(q2)"
    if isinstance(w, Piecewise):
       for i, (e, c) in enumerate(w.args):
           (de, dc) = dw.args[i]
           (d2e, d2c) = d2w.args[i]
           (fe,fc) = fsoft.args[i]
           (pe,pc) = pot.args[i]
           (pdhe,pdhc) = dpotdh.args[i]
           if i == 0:
              print "       if (%s) then" %fmt(c)
           elif i == len(w.args)-1 and c == True:
              print "       else"
           else:
              print "       elseif (%s) then" %fmt(c)
           print "          wkern(i)     = %s " %fmtn(e)
           print "          grwkern(i)   = %s " %fmtn(de)
           print "          grgrwkern(i) = %s " %fmtn(d2e)
           print "          fsoft(i)     = %s " %fmtn(fe)
           print "          potensoft(i) = %s " %fmtn(pe)
           print "          dphidh(i)    = %s " %fmtn(pdhe)
       print "       endif"
    else:
       print w
    print "    enddo\n"

def printkernel_phantom(w,R,name):
    dw, d2w, c1D, c2D, c3D, fsoft, pot, dpotdh = getkernelfuncs(w,R)
    w0 = w.subs(q,0)
    dpotdh0 = dpotdh.subs(q,0)
    #
    #--double-hump kernel used in drag routines, with normalisation
    #
    wdrag = piecewise_fold(w*q*q)
    c3Ddrag = sympify(1)/(integrate(4*pi*q*q*wdrag,(q,0,R)))
    lb = "!"+"-"*62
    print "! $Id: kernel_%s.f90 $" %name
    print lb
    print "! This module is or was part of the Phantom SPH code"
    print "! See LICENCE file for use conditions"
    print "! (c) 2012 Daniel Price \n%s" %lb
    print "!+\n!  This module contains the functional form of the SPH kernel"
    print "!  DO NOT EDIT THIS FILE: auto-generated by kernels.py"
    print "!+\n%s" %lb
    print "module kernel"
    print " use physcon, only:pi"
    print " implicit none"
    print " character(len=%i), public :: kernelname = '%s'" %(len(name),name)
    print " real, parameter, public :: radkern  = %.1f" %(R)
    print " real, parameter, public :: radkern2 = %.1f" %(R*R)
    print " real, parameter, public :: cnormk = %s" %fmt(c3D)
    print " real, parameter, public :: wab0 = %s, gradh0 = -3.*wab0" %fmt(w0)
    print " real, parameter, public :: dphidh0 = %s" %fmt(dpotdh0)
    print " real, parameter, public :: cnormk_drag = %s " %fmt(c3Ddrag)
    print "\ncontains\n"
    print "pure subroutine get_kernel(q2,q,wkern,grkern)"
    print " real, intent(in)  :: q2,q"
    print " real, intent(out) :: wkern,grkern"
    print "\n !--%s" %name
    if isinstance(w, Piecewise):
       for i, (e, c) in enumerate(w.args):
           (de, dc) = dw.args[i]
           if i == 0:
              print " if (%s) then" %fmt(c)
           elif i == len(w.args)-1 and c == True:
              print " else"
           else:
              print " elseif (%s) then" %fmt(c)
           print "    wkern  = %s" %fmtp(e)
           print "    grkern = %s" %fmtp(de)
       print " endif"
    else:
       print w
    print "\nend subroutine get_kernel\n"
    print "pure elemental real function wkern(q2,q)"
    print " real, intent(in) :: q2,q\n"
    if isinstance(w, Piecewise):
       for i, (e, c) in enumerate(w.args):
           if i == 0:
              print " if (%s) then" %fmt(c)
           elif i == len(w.args)-1 and c == True:
              print " else"
           else:
              print " elseif (%s) then" %fmt(c)
           print "    wkern = %s" %fmtp(e)
       print " endif"
    else:
       print "    wkern = %s" %w
    print "\nend function wkern\n"
    print "pure elemental real function grkern(q2,q)"
    print " real, intent(in) :: q2,q\n"
    if isinstance(dw, Piecewise):
       for i, (e, c) in enumerate(dw.args):
           if i == 0:
              print " if (%s) then" %fmt(c)
           elif i == len(w.args)-1 and c == True:
              print " else"
           else:
              print " elseif (%s) then" %fmt(c)
           print "    grkern = %s" %fmtp(e)
       print " endif"
    else:
       print "    grkern = %s " %fmtp(dw)
    print "\nend function grkern\n"
    print "pure subroutine get_kernel_grav1(q2,q,wkern,grkern,dphidh)"
    print " real, intent(in)  :: q2,q"
    print " real, intent(out) :: wkern,grkern,dphidh\n"
    if isinstance(w, Piecewise):
       for i, (e, c) in enumerate(w.args):
           (de, dc) = dw.args[i]
           (dphie, dphic) = dpotdh.args[i]
           if i == 0:
              print " if (%s) then" %fmt(c)
           elif i == len(w.args)-1 and c == True:
              print " else"
           else:
              print " elseif (%s) then" %fmt(c)
           print "    wkern  = %s" %fmtp(e)
           print "    grkern = %s" %fmtp(de)
           print "    dphidh = %s" %fmtp(dphie)
       print " endif"
    else:
       print "    wkern  = %s" %fmtp(w)
       print "    grkern = %s" %fmtp(dw)
       print "    dphidh = %s" %fmtp(dpotdh)
    print "\nend subroutine get_kernel_grav1\n"
    print "pure subroutine get_kernel_grav2(q2,q,grkern,potensoft,fsoft)"
    print " real, intent(in)  :: q2,q"
    print " real, intent(out) :: grkern,potensoft,fsoft\n"
    if isinstance(dw, Piecewise):
       for i, (de, c) in enumerate(dw.args):
           (pote, potc) = pot.args[i]
           (fe, fc) = fsoft.args[i]
           if i == 0:
              print " if (%s) then" %fmt(c)
           elif i == len(dw.args)-1 and c == True:
              print " else"
           else:
              print " elseif (%s) then" %fmt(c)
           print "    grkern    = %s" %fmtp(de)
           print "    potensoft = %s" %fmtp(pote)
           print "    fsoft     = %s" %fmtp(fe)
       print " endif"
    else:
       print "    wkern     = %s" %fmtp(w)
       print "    grkern    = %s" %fmtp(dw)
       print "    potensoft = %s" %fmtp(pot)
       print "    fsoft     = %s" %fmtp(fsoft)
    print "\nend subroutine get_kernel_grav2\n"
    print "!------------------------------------------"
    print "! double-humped version of the kernel for"
    print "! use in drag force calculations"
    print "!------------------------------------------"
    print "pure elemental real function wkern_drag(q2,q)"
    print " real, intent(in) :: q2,q\n"
    print " !--double hump %s kernel" %name
    if isinstance(wdrag, Piecewise):
       for i, (e, c) in enumerate(wdrag.args):
           if i == 0:
              print " if (%s) then" %fmt(c)
           elif i == len(wdrag.args)-1 and c == True:
              print " else"
           else:
              print " elseif (%s) then" %fmt(c)
           print "    wkern_drag = %s" %fmtp(e)
       print " endif"
    else:
       print "    wkern_drag = %s" %fmtp(wdrag)
    print "\nend function wkern_drag\n"
    print "end module kernel"

def intconst(g):
    #
    #--work out the integration constant
    #  by matching the different parts of the piecewise function
    #
    if isinstance(g, Piecewise):
       garg = list(g.args)
       for i, (e, c) in reversed(list(enumerate(g.args))):
           if i < len(g.args) - 1:
              (ep, cp) = garg[i+1]
              s = "%s" %c
              qval = sympify(s.split()[2])
              ge = simplify(e + (ep.subs(q,qval) - e.subs(q,qval)))
              garg[i] = (ge,c)
       tuple(garg)
       g = Piecewise(*garg)
    return g

def m4(R):
    f = Piecewise((1 - sympify(3)/2*q*q + sympify(3)/4*q**3,q < R/2), (sympify(1)/4*(2-q)**3, q < R), (0, True))
    return(f,'M4 cubic')

def intm4(R):
    f, name = m4(R)
    g = piecewise_fold(integrate(-q*f,q))
    g = intconst(g)
    g = piecewise_fold(integrate(-q*g,q))
    g = intconst(g)
    g = piecewise_fold(integrate(-q*g,q))
    g = intconst(g)
    return(g,'triple-integrated M4')

def m5(R):
    term1 = sympify((R-q)**4)
    term2 = -5*(sympify(3)/5*R - q)**4
    term3 = 10*(sympify(1)/5*R - q)**4
    f = Piecewise((term1 + term2 + term3,q < sympify(1)/5*R), (term1 + term2, q < sympify(3)/5*R), (term1, q < R), (0, True))
    return(f,'M5 quartic')

def m6(R):
    f = symbols('f',cls=Function)
    term1 = sympify((R-q)**5)
    term2 = -6*(sympify(2)/3*R - q)**5
    term3 = 15*(sympify(1)/3*R - q)**5
    f = Piecewise((term1 + term2 + term3,q < sympify(1)/3*R), (term1 + term2, q < sympify(2)/3*R), (term1, q < R), (0, True))
    return(f,'M6 quintic')

def w2_1D(R):
    f = Piecewise(((1 - q/R)**3*(1 + 3*q/R),q < R), (0, True))
    return(f,'Wendland 1D kernel of degree 2')

def w4_1D(R):
    f = Piecewise(((1 - q/R)**5*(1 + 5*q/R + 8*(q/R)**2),q < R), (0, True))
    return(f,'Wendland 1D kernel of degree 4')

def w6_1D(R):
    f = Piecewise(((1 - q/R)**7*(1 + 7*q/R + 19*(q/R)**2 + 21*(q/R)**3),q < R), (0, True))
    return(f,'Wendland 1D kernel of degree 6')

def sinq(R,n):
    f = Piecewise(((sin(pi*q/R)/q)**n,q < R), (0, True))
    name = "[sin(q)/q]**%i" %n
    return(f,name)

def w2(R):
    f = Piecewise(((1 - q/R)**4*(1 + 4*q/R),q < R), (0, True))
    return(f,'Wendland 2/3D kernel of degree 2')

def w4(R):
    f = Piecewise(((1 - q/R)**6*(1 + 6*q/R + sympify(35)/3*(q/R)**2),q < R), (0, True))
    return(f,'Wendland 2/3D kernel of degree 4')

def w6(R):
    f = Piecewise(((1 - q/R)**8*(1 + 8*q/R + 25*(q/R)**2 + 32*(q/R)**3),q < R), (0, True))
    return(f,'Wendland 2/3D kernel of degree 6')

#string = sympify(0.0625*q +q**2*q + 2 + q**4/3 + 100./40000.*q**5)
#print "string = ",string
#print "news = %s \n" %fmte(string)
#import sys
#sys.exit()
f = symbols('f',cls=Function)
q = symbols('q')
R = 2 #sympify(5)/2
#f, name = sinq(R,3)
f, name = w6(R);
#
#--construct Guillaume's super-kernels for 3D
#
#g = piecewise_fold(-diff(f,q)/q)
#name = '3D quintic spline'
#printkernel(f,R)
printkernel_ndspmhd(f,R,name)
#printkernel_phantom(f,R,name)
