\documentclass[a4paper,11pt]{article}
\usepackage{natbib,epsfig,rotating,longtable,url,amsmath}
\usepackage{varioref}
%% font
\usepackage{mathptmx}
\graphicspath{{figs/}}
\setlength{\topmargin}{-1.5cm}
\setlength{\textheight}{22.5cm}
\setlength{\oddsidemargin}{0.3cm}
\setlength{\evensidemargin}{0.3cm}
\setlength{\textwidth}{16cm}

\begin{titlepage}
\title{Visualisation of SPH data using SUPERSPHPLOT - v\input{version}}
\author{Daniel Price}
\end{titlepage}

\begin{document}
\begin{figure}
\begin{center}
\begin{turn}{270}\epsfig{file=hyperbolic.ps,height=\textwidth}\end{turn}
\end{center}
\end{figure}
\maketitle
\tableofcontents
\newpage

\section{Introduction}
 Whilst many wonderful commercial software packages exist for visualising scientific
data (such as the widely used Interactive Data Language), I found that such packages
could be somewhat cumbersome for the manipulation and visualisation of my SPH data. The
main problem was that much of what I wanted to do was fairly specific to SPH (such as
interpolation to an array of pixels using the kernel) and whilst generic routines exist
for such tasks, I could not explain how they worked, nor were they
particularly fast and whilst interactive gizmos are handy, it can prove more difficult to perform the
same tasks non-interactively, as required for the production of animations. 
In fact I have found that the major
work in the visualisation of SPH data is not the image production itself but the
manipulation of data prior to plotting. Much of this manipulation makes sense
within an SPH framework (for example the interpolation provided by the kernel
and rotation of the particles for perspective).

 SUPERSPHPLOT is designed for this specific task - to use SPH tools to analyse SPH data and to make this a
straightforward task such that publishable images and animations can be obtained
as efficiently as possible from the raw data with a minimum amount of effort
from the user. I have found in the process that the development of powerful
visualisation tools has enabled me to pick up on effects present in my
simulation results that I would not otherwise have noticed (in particular the
difference between a raw particle plot and a rendered image can be substantial). Part of the goal of
SUPERSPHPLOT is to eliminate the use of crap-looking particle plots as a means of representing SPH data!

\subsection{What it does}
SUPERSPHPLOT is a utility for visualisation of output from (astrophysical) simulations using the
Smoothed Particle Hydrodynamics (SPH) method in one, two and three dimensions.
It is written in Fortran 90/95 and
utilises PGPLOT subroutines to do the actual plotting. In particular the following
features are included:
\begin{itemize}
\item Rendering of particle data to an array of pixels using the SPH kernel
\item Cross-sections through 2D and 3D data (as both particle plots and rendered
images).
\item Fast projections through 3D data (ie. column density plots, or integration of
other quantities along the line of sight)
\item Vector plots of the velocity (and other vector quantities), including vector
plots in a cross section slice in 3D.
\item Rotation and fly-throughs (multiple cross-section slices) of 3D data.
\item Automatic stepping through timesteps, making animations simple to produce.
\item Interactive mode for detailed examination of timestep data (e.g. zooming,
rotating, plotting particle labels, working out the gradient of a line, stepping forwards/backwards
through timesteps)
\item Multiple plots on page, including option to automatically tile plots if $y-$ and $x-$ limits
are the same.
\item Plot limits can be fixed, adaptive or particle tracking. Also simple to change
axes to log, invert, square root or absolute of a quantity.
\item Exact solutions for common SPH test problems (e.g. hydrodynamic shock tubes,
polytropes).
\item Calculation of quantities not dumped (e.g. pressure, entropy)
\item Transformation to different co-ordinate systems (for both co-ordinates and
vector components).
\item Straightforward production of GIF and Postscript images which can then be
converted into animations or inserted into \LaTeX documents.
\end{itemize}

\subsection{What it doesn't do}
At the moment SUPERSPHPLOT is geared towards gas dynamics
simulations with SPH and has basically grown out of my visualisation needs.
Thus it may not be particularly useful for things like water and solids etc. in SPH.

\subsection{Version History}

\begin{tabular}{|l|l|p{0.75\textwidth}|}
\hline
\input{version_history_tex}
\hline
\end{tabular}

\subsection{Licence}
SUPERSPHPLOT - a visualisation tool for SPH data \copyright 2005 Daniel Price.
 This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA.

\section{Getting started}
\subsection{Compiling the code}
The basic steps for installation are as follows:
\begin{enumerate}
\item make sure you have a Fortran 95 compiler (such as g95)
\item make sure you have the PGPLOT libraries installed
\item compile SUPERSPHPLOT and link with PGPLOT
\item write a read\_data subroutine so that SUPERSPHPLOT can read your data format
\end{enumerate}

\subsubsection{Fortran 90/95 compilers}
 By now, many Fortran 90/95 compilers exist. In terms of free ones, the Intel compiler has a
 non-commercial version available for linux and the
g95 compiler, downloadable from:
\begin{quote}
\url{http://www.g95.org}
\end{quote}
successfully compiles SUPERSPHPLOT and if necessary the PGPLOT libraries.

\subsubsection{PGPLOT}
 The PGPLOT
graphics subroutine library is freely downloadable from
\begin{quote}
\url{http://www.astro.caltech.edu/~tjp/pgplot/}
\end{quote}
or by ftp from
\begin{quote}
\url{ftp://ftp.astro.caltech.edu/pub/pgplot/pgplot5.2.tar.gz}
\end{quote}
however check to see if it is already installed on your system (if so, the libraries are
usually located in /usr/local/pgplot). For details of the actual plotting subroutines
used by the SUPERSPHPLOT source code, you may want to refer to the PGPLOT userguide:
\begin{quote}
\url{http://www.astro.caltech.edu/~tjp/pgplot/contents.html}
\end{quote}

\subsubsection{Reading your data}
 The most important part is getting SUPERSPHPLOT to read your data format.
If you are using a publically available code, it is reasonably likely that I
have already written a read data subroutine which will read your dumps.
If not it is best to look at some of the other examples and change the 
necessary parts to suit your data files. Note that reading directly from
unformatted data files is *much* faster than reading from formatted (ascii)
output.   

I have supplied subroutines for reading output from the publically available
GADGET code (\verb+read_data_gadget.f90+) and also for Matthew Bate's SPH code
(\verb+read_data_mbate.f90+) which is widely used in the UK. Another example of a
data read which I use is given in \verb+read_data_dansph.f90+.

Further details on writing your own subroutine are given in
appendix~\ref{sec:writeyourown}. The *easiest* way is to email me a sample data file and the subroutine
you used to write it and I can then create a data read for your file format.

\subsubsection{Compiling and linking with PGPLOT}

 In the Makefile, you will need to set the Fortran compiler and flags to your local version, e.g..
\begin{verbatim}
F90C = g95
F90FLAGS = -O
\end{verbatim}
 Secondly the compiler must be able to link to the PGPLOT and X11 libraries on
your system. As a first attempt try using:
\begin{verbatim}
LDFLAGS = -lpgplot -lX11
\end{verbatim}
If that works at a first attempt, take a moment to think several happy thoughts about your system
administrator. If these libraries are not found, you will need to enter the
library paths by hand. On most systems this is something like:
\begin{verbatim}
LDFLAGS = -L/usr/local/pgplot -lpgplot -L/usr/X11R6/lib -lX11
\end{verbatim}
(assuming the PGPLOT libraries are in the /usr/local/pgplot directory and the
X11 libraries are in /usr/X11R6/lib). If this does not work, try using the
\verb+locate+ command to find the libraries on your system:
\begin{verbatim}
locate libpgplot
locate libX11
\end{verbatim}
 If, having found the PGPLOT and X11
libraries, the program still won't compile, it is usually
because the PGPLOT on your system has been compiled with a different compiler to
the one you are using. A first attempt is to try using the g2c libraries
\begin{verbatim}
LDFLAGS = -L/usr/local/pgplot -lpgplot -L/usr/X11R6/lib -lX11 -lg2c
\end{verbatim}
If the PNG drivers are incorporated into the PGPLOT installation, the \verb+-lpng+ libraries must also be added.
Failing that, ask your system administrator(!) or simply download your own copy of
the PGPLOT libraries and make sure it is compiled with the same compiler as you
are using to compile the SUPERSPHPLOT source code.

\begin{table}
\begin{center}
\begin{tabular}{|l|l|p{0.3\textwidth}|}
\hline
compiler & flags & notes \\
\hline
g95 & F90C = g95 & \\
    & F90FLAGS = -O3 & \\ 
    & SYSTEMFILE = system\_f2003.f90 & g95 accepts Fortran 2003 system commands\\
\hline
ifc & F90C = ifc & \\
    & F90FLAGS = -03 -Vaxlib -nbs & -nbs treats backslashes as normal characters\\
    & SYSTEMFILE = system\_unix.f90 & \\
\hline
NAG f95 & F90C = f95 & \\
        & F90FLAGS = -0  & \\
        & SYSTEMFILE = system\_unix\_NAG.f90 & \\
\hline
\end{tabular}
\end{center}
\end{table}
\subsection{Environment variables}
 Several useful environment variables can be set for PGPLOT and several of them
are very useful for SUPERSPHPLOT. In a tcsh shell type:
\begin{verbatim}
setenv PGPLOT_DEV /xwin
setenv PGPLOT_BACKGROUND white
setenv PGPLOT_FOREGROUND black
\end{verbatim}
The first command sets the default device to the X-window, rather than the /null
device. The latter two commands set the background and foreground colours of the
plotting page. Note that these environment variables should be set \emph{before}
invoking supersphplot (it is simplest to set them upon starting the shell by placing
them in your .tcshrc or bash/sh equivalent file). For other environment
variables which can be set, refer to the PGPLOT user guide.

\subsection{System dependent routines}
 System dependent subroutines are interfaced in a separate \verb+system+ module in the file \verb+system_unix.f90+.
At present the only calls to these routines are made from \verb+supersphplot.f90+ which
reads the run name(s) from the command line. A standardised format for performing this
task is included in the standards for the next release of Fortran (Fortran 2003),
however in the meantime the calls in the \verb+system+ module may require some adjustment depending on the
particular system you are compiling the code on. The program is still fully
functional without this call working, but it does make things convenient (in particular it means that
SUPERSPHPLOT can be invoked using wildcards ($*,?$) in filenames).

\section{A brief tour...}
 Once you have a read data file that will read your data format,
SUPERSPHPLOT is invoked with the name of the data
file(s) on the command line, e.g.
\begin{verbatim}
supersphplot myrun*.dat
\end{verbatim}

After a successful data read, the menu should appear as something like the
following:
\begin{verbatim}
 You may choose from a delectable sample of plots
 -------------------------------------------------------
  1) x                     7) particle mass
  2) y                     8) u
  3) z                     9) \gr
  4) v\dx                 10) pressure
  5) v\dy                 11) entropy
  6) v\dz                 12) h
 -------------------------------------------------------
 13) multiplot [  4 ]      m) set multiplot
 -------------------------------------------------------
  d(ata) i(nteractive) p(age) o(pts) l(imits) h(elp)
  r(ender) v(ector) x(sec/rotate) s(ave) q(uit)
 -------------------------------------------------------
Please enter your selection now (y axis or option):
\end{verbatim}
The simplest plot is of two quantities where only one is a coordinate, for
example
\begin{verbatim}
Please enter your selection now (y axis or option): 9
(x axis) (<cr>=1): 1
 Graphics device/type (? to see list, default /xwin): /xw
\end{verbatim}
 A full list of available graphics devices is given in the PGPLOT user guide.
Some of the most useful devices are given in table \ref{tab:devices}. In the
above we have selected the X-window driver which means that the output is sent to the
screen, producing the graph shown in Figure \ref{fig:swave1D}.
\begin{table}[h]
\centering
\begin{tabular}{|l|l|}
\hline
\verb+/xw+, \verb+/xwin+ & X-Window (interactive) \\
\verb+/ps+ & Postscript (landscape) \\
\verb+/vps+ & Postscript (portrait) \\
\verb+/cps+ & Colour Postscript \\
\verb+/gif+ & GIF \\
\verb+/png+ & PNG (if installed) \\
\verb+/null+ & null device (no output) \\
\hline
\end{tabular}
\caption{Commonly used graphics devices available in PGPLOT}
\label{tab:devices}
\end{table}

\begin{figure}
\centering
\caption{example plot}
\end{figure}
 Plot settings are controlled via the menu options and are described below. 


\section{Menu options}
 The program options may be changed in a series of submenus. The defaults for all of
these options are initially set in the subroutine defaults\_set. The options set using
the submenus can be saved using the (s)ave option from the menu. This saves all of
the current options to a file called `defaults' in the current directory, which is
automatically read upon starting supersphplot the next time. This file is written using
the namelist formatting option provided by Fortran 90. An alternative way of setting
options is to edit this file directly prior to invoking the program.

\subsection{set (m)ultiplot}
 The multiplot option enables plotting of several different plots on the same
physical page. Plots with the same $x-$ and $y-$ axes are tiled if the tiling
option from the (p)age options menu (\S\vref{sec:optionspage}) is set. Each plot
can have independent $x-$ and $y-$ axes as well as a different rendering (cross
section or projection) and/or vector plot. For rendered plots plotting of
contours can be turned on/off between plots and for cross sections the position of
the cross section can also be changed between plots. An alternative method for
specifying a multiplot is to edit the \verb+defaults+ file directly prior to
starting SUPERSPHPLOT.

\subsection{(d)ata options}
These options relate to the data read and are as follows:
\begin{enumerate}
\item \textbf{read new data /re-read data}. Read new data, using a different runname.
\item \textbf{change number of timesteps used}. Set timestep number to start
reading from, timestep number to stop reading from and the frequency of
timesteps to read (e.g. every two steps). This can also be changed interactively in
interactive mode.
\item \textbf{plot selected steps only}. Here you can choose to plot only a selected
few timesteps (in any order).
\item \textbf{buffering of data on/off}. Turn buffering of input data on/off.
Buffering on means that all the timesteps are read into memory (good for small
data sets). Buffering off means that only one data file at a time is read into
memory. Default is off.
\item \textbf{turn calculate extra quantities on/off}. Turns on/off the calculation
of additional data columns (e.g. radius and magnitudes of vector quantities) from the main data.
\item \textbf{use physical units}. Switches between code units (or ``data file units") and rescaled
``physical" units (with amended labels). Some data reads (sphNG, srosph, mbate) now set the transformations
between physical units and code units. Alternatively these transformations can be set manually using the next menu
item.
\item \textbf{change physical unit settings}. Enables rescaling of columns. This
is useful for changing units but also for changing the axis labels. For
example, where the $y-$axis looks crowded because the numeric axis labels read something
like $1\times 10^{-4}$, the rescaling option can be used to rescale the data so
that the numeric label reads $1$ whilst the label string is amended to read $y
[\times 10^{-4}]$.
\end{enumerate}

\subsection{(i)nteractive mode}
 The menu option turns on/off interactive mode. With this option turned on and
an appropriate device selected (ie. the X-window, not /gif or /ps), after
each plot the program waits for specific commands from the user. With the cursor
positioned anywhere in the plot window (but not outside it!), many different
commands can be invoked. Some functions you may find useful are: Move through timesteps by pressing the space bar (press
 `b' to go back); zoom in by selecting an area with the mouse; rotate the
particles by using the $<$, $>$,[, ] and $\backslash$, / keys; log the axes by holding the cursor
over the appropriate axis and pressing the `l' key. Press `q' in the plot window
to quit interactive mode.

 A full list of these commands is obtained by holding
the cursor in the plot window and pressing the `h' key (h for help). Note that changes made in interactive mode will only be saved by pressing the
`s' (for save) key. Otherwise pressing the space bar (to advance to the next
timestep) erases the changes made whilst in interactive mode. A somewhat limited
interactive mode applies when there is more than one plot per page. If the multiplot option has been used, the timestep changing commands only
take effect on the last plot per timestep.

 Many more commands could be added to
the interactive mode, limited only by your imagination. Please send me your suggestions!

\subsection{(p)age options}
\label{sec:optionspage}
 This submenu contains options relating to the PGPLOT page setup. The options are as follows:
\begin{enumerate}
\item \textbf{change steps per plot}. (default=1) Allows multiple timesteps to be plotted on
the same page.
\item \textbf{axes options}. Changes the appearance of the axes. The variable is
the same as the AXIS variable used in the call to PGENV in the standard PGPLOT
routines, except that I have also added the $-3$ option. The options are
as follows:

\begin{tabular}{rcp{0.8\textwidth}}
-3 & : & same as AXIS=-1, but also draw tick marks; \\
 -2 & : & draw no box, axes or labels; \\
 -1 & : & draw box only; \\
  0 & : & draw box and label it with coordinates; \\
  1 & : & same as AXIS=0, but also draw the coordinate axes (X=0, Y=0); \\
  2 & : & same as AXIS=1, but also draw grid lines at major increments of the coordinates;
\end{tabular}

\item \textbf{change paper size}. Sets the size of the plotting page.
\item \textbf{change plots per page}. Changes the number of plots on each
physical page.
\item \textbf{toggle plot tiling}. When set, plots with more than one plot on
the page and the same $y-$ and $x-$ axes are automatically tiled together.
\item \textbf{title options}. Adjusts the position of the title on
each plot. To turn off plot titling, set the position outside the viewport (ie.
enter some large numbers). For details of plot titling see \S\vref{sec:title}
\item \textbf{legend options}. Adjusts the position of the legend on
each plot. Again, to turn off the legend, set the position outside of the
viewport (ie. enter some large numbers). To customise the legend see
\S\vref{sec:legend}
\item \textbf{set foreground/background colours}. Does what it says.
\end{enumerate}

\subsection{particle plot (o)ptions}
 These options relate to pure `particle plots'. The options are as follows:
\begin{enumerate}
\item \textbf{plot line joining particles}. When set, this option plots a line connecting the (gas only) particles
in the order that they appear in the data array. Useful mainly in one dimension or when plotting ascii data, although can give an indication of the
relative closeness of the particles in memory and in physical space in higher dimensions. The line colours and
styles can be changed.

 To plot the line only with no particles, use the option 4) from this menu to turn off
plotting of gas particles.

 When multiple timesteps are plotted on the same physical page, the line style can be
changed instead of the colour (this occurs when the change colour option is chosen for multiple steps per page
-- see the ``change plots per page" option in the p)age options submenu [\S\vref{sec:optionspage}]).
\item \textbf{toggle label particles}. This option prints the number of each particle
next to its position on the plot (for all particles). Primarily useful for debugging neighbour finding
routines. An alternative is to use the `p' option in interactive mode.
\item \textbf{plot circles of interaction}. On coordinate plots this option plots a circle of
radius $2h$ around selected particles. 
This is primarily useful in debugging neighbour finding routines. Where only one of the axes is a 
coordinate this function plots an error bar of length $2h$ in either direction is plotted
in the direction of the coordinate axis.
\item \textbf{toggle plot particles by type}. Enables particles of certain types only to be plotted
(e.g. dark matter particles only, gas particles only etc.). Also prompts to allow particles of given types to be
plotted on top of rendered plots (useful for sink or star particles). This is not allowed for gas
(SPH) particles.
\item \textbf{change graph markers for each type}. This option sets the PGPLOT marker used for each
type of particle in the particle plots. The list of markers is given in the
PGPLOT user guide and is also listed in Appendix \ref{sec:pgplotmarkers}. 
\item \textbf{change co-ordinate systems}. This feature transforms the particle
co-ordinates \emph{and} vector components into non-cartesian co-ordinate systems. Note that
renderings can only be done in the base co-ordinate system so that the interpolation using the SPH
kernel and $h$ is correct.  
\item \textbf{plot exact solution}. The following exact solutions are provided
\begin{itemize}
\item Hydrodynamic shock tubes (Riemann problem)
\item Spherically-symmetric sedov blast wave problem.
\item Polytropes (with arbitrary $\gamma$)
\item One dimensional toy stars. This is a particularly simple test
problem for SPH codes described in \citet{mp04}.
\item Linear wave. This simply plots a sine wave of a specified amplitude, period and
wavelength on the plot specified.
\item MHD shock tubes (tabulated). These are tabulated solutions for 7 specific MHD
shock tube problems.
\item h vs $\rho$. This is the exact solution relating smoothing length and density in
the form $h \propto (m/\rho)^{1/\nu}$ where $\nu$ is the number of spatial dimensions.
\item radial density profiles. For various models commonly used in $N-$body simulations.
\item Exact solution from a file. This option reads in an exact solution from the
filename input by the user, assuming the file contains two columns containing the $x-$ and $y-$ co-ordinates of
an exact solution to be plotted as a line on the plot specified.
\end{itemize}
Details of the calculation of the exact solutions and examples of their output are
given in Appendix~\ref{sec:exact}.
\item \textbf{exact solution options}. These options allow you to change the colour and line
style of the exact solution plot. Also turns on/off calculation of various error norms
together with an inset plot of the residual error on the particles. See
Appendix~\ref{sec:exact} for details.
\end{enumerate}


\subsection{plot (l)imits}
\label{sec:optionslimits}
 The options for plot limits are as follows:
\begin{enumerate}
\item \textbf{set adaptive/fixed limits}. With limits set to adaptive, plot
limits are minimum and maximum of quantities at current
timestep. With fixed limits, the plot limits retain their default values
for all timesteps. An independent setting applies to the particle co-ordinates.
\item \textbf{set manual limits}. Manually set the limits for each column of
data.
\item \textbf{x-y limits track particle}. Co-ordinate limits are centred on the
selected particle for all timesteps, with offsets as input by the user. This
effectively gives the `Lagrangian' perspective.
\item \textbf{zoom in/out}. Multiplies the current limits by a fixed factor.
\item \textbf{apply transformations (log,1/x)}. Allows you to apply transformations such as log, 1/x, sqrt
etc. to selected data columns.
\item \textbf{save current limits to file}. Saves the current values of the
limits calculated from the data read or set manually using option 2 to a
file (default name is `filename.limits') where filename is the name of the first data file
read. If using the default filename, this limits file is automatically read upon the next
invocation of supersphplot with the same filename.
Otherwise the limits file can be read by choosing option 7 from this submenu. The limits apply
only when fixed limits are set.
\item \textbf{re-read limits file}. Re-reads the plot limits from the
limits file. Note that these limits will only apply if fixed plot limits are set.
\item \textbf{reset limits for all plots}. Recalculates the limits for all columns based on
the data currently in memory.
\end{enumerate}

\subsection{(r)endering options}
\begin{enumerate}
\item \textbf{change number of pixels}. Set the number of pixels along the
$x-$axis. Pixels are assumed to be square such that the number of pixels along
the $y-$axis is determined by the aspect ratio of the current plot.
\item \textbf{change colour scheme}. Changes the colour scheme used on rendered
images. A demonstration of all the colour schemes can be also be invoked from
this menu option. Setting the colour scheme to zero plots only the contours of
the rendered quantity (assuming that plot contours is set to true). The colour
schemes given are shown in Figure~\ref{fig:colourschemes} and are as follows:

\begin{tabular}{rcp{0.8\textwidth}}
  0 & : & contours only \\
  1 & : & greyscale \\
  2 & : & red \\
  3 & : & ice blue \\
  4 & : & heat \\
  5 & : & rainbow \\
  6 & : & prism \\
  7 & : & red-blue-yellow \\
  8 & : & blue-yellow-red \\
  9 & : & purple-blue-green \\
  10 & : & gamma \\
  11 & : & gamma- no black \\
  12 & : & red-green-blue \\
  13 & : & blue-green-red \\
  14 & : & rainbow I \\
  15 & : & rainbow II \\
\end{tabular}

\begin{figure}
\begin{center}
\begin{turn}{270}\epsfig{file=colourschemes.ps,height=\textwidth}\end{turn}
\caption{SUPERSPHPLOT colour schemes}
\label{fig:colourschemes}
\end{center}
\end{figure}
Note that the colour scheme can also be changed interactively by pressing m or M
in interactive mode.

 User contributed colour schemes are eagerly invited (see the subroutine
`colour\_set' for details on how to do this).

\item \textbf{toggle plot contours}. Determines whether or not to plot contours
in addition to the rendered quantity.
\item \textbf{change number of contours}. Sets the number of contours to be
plotted. 
\item \textbf{colour bar options}. Sets options relating to the colour
bar on rendered images.
\item \textbf{use particle colours not pixels}. With this option set, rendered plots are
simply plotted by colouring the particles according to the rendered field. This is somewhat
cruder but can be a good indication of where individual particles might be affecting results.
Note that any colouring of the particles set in interactive mode will be overwritten.
\item \textbf{normalise interpolations}. This option means that the SPH interpolations are
normalised. In general this leads to smoother rendering but also means that edges and surfaces appear
more prominently (and a bit strange). Note that this option only affects cross-section slices. Default is off.
\end{enumerate}

\subsection{(v)ector plot options}
\begin{enumerate}
\item \textbf{change number of pixels}. Set the number of pixels along the
$x-$axis to be used in the vector plots. As in the rendered images, pixels are assumed to be square such that the number of pixels along
the $y-$axis is determined by the aspect ratio of the current plot.
\item \textbf{toggle background/foreground colour}. Determines whether or not to
plot the vector arrows in the current background or foreground colour (by
default these are white and black respectively). This must
be user determined to give the best contrast between the vector arrows and the
rendered image.
\item \textbf{vector plot legend settings}. Options for vector plot legend. Note that the position can also be set
interactively.
\end{enumerate}

\subsection{(x) cross section/rotation options}
\begin{enumerate}
\item \textbf{switch between cross section/projection}. For 3D data, whether to
plot the rendered quantity integrated along the line of sight (projection) or in
a particular cross section along the line of sight. For 2D data setting the
cross section option gives arbitrary 1D cross sections through 2D data. Also applies to vector plots.
\item \textbf{set cross section position}. Sets the position of the cross section slice.
\item \textbf{rotation settings/options}. Turns rotation on/off. Allows manual setting of rotation
angles and the origin about which to rotate.
\item \textbf{3D perspective}. Turns 3D perspective on/off (ie. objects at larger z distance get
smaller).
\item \textbf{3D surface rendering on/off/options}. 3D surface rendering performs a ray-trace through
the particle data, thus visualising the "last scattering surface". When set, the user is prompted for
an "optical depth" before plotting which determines the position of the surface. Only applies to 3D
data. When set with cross-section (instead of projection), particles at or below the z value of the
slice are used.
\item \textbf{set axes for rotated/3D plots}. Allows you to plot rotated axes, boxes and planes
in two and three dimensions. At present these are plotted on top of the particle renderings.
\end{enumerate}

\subsection{(s)ave, (h)elp, (q)uit}
 The (s)ave option saves the default options to a file called `defaults' in the
current directory which is read automatically upon the next invocation of
supersphplot. The (h)elp option simply expands the text for the options menus (I
may add to this soon). (q)uit, unsurprisingly, quits. Typing a number greater than the number of
data columns also exits the program (e.g. I often simply type 99 to exit).

\section{Algorithms}

\subsection{Rendering of 2D data}
\subsubsection{Interpolation to pixels}
 For a contour or rendered plot of a scalar quantity $\phi$ we
interpolate from the particles to an array of pixels using the SPH summation
interpolant. In two dimensions the interpolant is simply
\begin{equation}
\phi(x,y) = \sum_b m_b \frac{\phi_b}{\rho_b} W(x - x_b, y-y_b, h_b)
\end{equation}
where the summation is over contributing particles and $W$ is the standard cubic spline kernel, given by
\begin{equation}
W(r,h) = \frac{\sigma}{h^\nu}\left\{ \begin{array}{ll}
1 - \frac{3}{2}q^2 + \frac{3}{4}q^3, & 0 \le q < 1; \\
\frac{1}{4}(2-q)^3, & 1 \le q < 2; \\
0 & q \ge 2 \end{array} \right. \label{eq:cubicspline}
\end{equation}
where $q = \vert {\bf r}_a - {\bf r}_b \vert / h$, $\nu$ is the number of spatial
dimensions and the normalisation constant $\sigma$ is given by $2/3$, $10/(7\pi)$ and $1/\pi$ in
1, 2 and 3 dimensions respectively.

\subsubsection{Cross sections of 2D data}
The cross-sectioning algorithm for 2D data (giving a 1D line) is slightly
different, in that it also works for oblique cross sections. The
cross-sectioning is done in the subroutine interpolate2D\_xsec. The cross
section is defined by two points (x1,y1) and (x2,y2) through which the line
should pass. These points are converted to give the equation of the line in the
form
\begin{equation}
y = mx + c
\end{equation}
This line is then divided evenly into pixels to which the particles
may contribute. The contributions along this line from the particles is computed
as follows: 

 For each particle, the points at which the cross section line intersects the
smoothing circle are calculated (illustrated in Figure \ref{fig:xsec2D}). The
smoothing circle of particle $i$ is defined by the equation
\begin{equation}
(x-x_i)^2 + (y-y_i)^2 = (2h)^2
\end{equation}
The x-coordinates of the points of intersection are the solutions to the quadratic equation
\begin{equation}
(1 + m^2) x^2 + 2 (m (c - y_i) - x_i) x + (x_i^2 + y_i^2 - 2cy_i + c^2 - (2h)^2)= 0
\end{equation}
For particles which do not contribute to the cross section line, the determinant
is negative. For the particles that do, it is then a simple matter of looping
over the pixels which lie between the two points of intersection, calculating
the contribution using the SPH summation interpolant
\begin{equation}
\phi = \sum_b m_b \frac{\phi_b}{\rho_b} W(x - x_b, h_b)
\end{equation}

\begin{figure}
\begin{center}
\epsfig{file=xsec2D.eps,width=0.5\textwidth}
\caption{Computation of a one dimensional cross section through 2D data}
\label{fig:xsec2D}
\end{center}
\end{figure}
 
 An example of a 1D cross section through 2D data is shown in Figure
\ref{fig:xsec2Dexample}.
\begin{figure}
\begin{center}
%%\begin{turn}{270}\epsfig{file=xsec2Dexample.ps,height=\textwidth}\end{turn}
%%\label{fig:xsec2Dexample}
\end{center}
\end{figure}

 In principle a similar method could be used for oblique cross sections
through 3D data. In this case we would need to find the intersection
between the smoothing sphere and the cross section plane. However
in 3D it is simpler just to rotate the particles first and then take
a straight cross section as described above.

\subsection{Rendering of 3D data}
 In three dimensions we must take either a projection through the whole domain or a cross section slice.
 
\subsubsection{Projections (line of sight integration)}
\label{sec:proj}
 In the projection case we wish to obtain an integral of the rendered quantity along the line of sight. We
begin with the SPH summation interpolant \citep{monaghan92} in the form
\begin{equation}
f(x,y,z) = \sum_b m_b \frac{\phi_b}{\rho_b} W(x - x_b, y-y_b, z-z_b, h_b)
\end{equation}
where $W$ is the usual (3D) cubic spline kernel (\ref{eq:cubicspline}). Taking the integral of both sides
along the line of sight (assumed to be along the z axis) we have
\begin{equation}
\int f(x,y,z) {\rm dz} = \sum_b m_b \frac{\phi_b}{\rho_b} \int W(x - x_b, y-y_b, z-z_b, h_b) {\rm dz}.
\end{equation}
This shows that the line-of-sight integration for three dimensions can be written as a two dimensional
interpolation
\begin{equation}
\phi(x,y) = \int f {\rm dz} = \sum_b m_b \frac{f_b}{\rho_b} Y(x - x_b, y-y_b, h_b).
\end{equation}
where the 2D kernel (denoted $Y$) is the 3D kernel integrated through one spatial
dimension, ie.
\begin{equation}
Y(x,y) = \int W(x,y,z) dz.
\end{equation}


For practical purposes we write $Y$ in the form
\begin{equation}
Y(r_{xy}, h) = \frac{2}{\pi h^2} F(q_{xy})
\end{equation}
where $q_{xy} = r_{xy}/h$ and $F(q_{xy})$ is given by
\begin{equation}
F(q_{xy}) = \left[ \int_{-q_{xy}}^{q_{xy}} f(q){\rm dq_z} \right] \label{eq:integratedform}
\end{equation}
where $q_z=z/h$, $q= q_{xy} + q_z$ and $f$ is the usual kernel function for the cubic spline, ie.
\begin{equation}
f(q) = \left\{ \begin{array}{ll}
1 - \frac{3}{2}q^2 + \frac{3}{4}q^3, & 0 \le q < 1; \\
\frac{1}{4}(2-q)^3, & 1 \le q < 2; \\
0 & q \ge 2 \end{array} \right.
\end{equation}
The integral (\ref{eq:integratedform}) is not (obviously) tractable analytically. However it is
straightforward to perform this integration numerically (for all $q_{xy}$'s from $0\to 2$) and store the results in a table for the
interpolation calculation. This is the method adopted in SUPERSPHPLOT. An alternative would be to use a
different kernel in the visualisation for which the above integral can be calculated analytically.


In the case of vector quantities each component is interpolated separately in the form
\begin{eqnarray}
f^x(x,y) & = & \sum_b m_b \frac{f^x_b}{\rho_b} Y(x - x_b, y-y_b, h_b), \nonumber \\
f^y(x,y) & = & \sum_b m_b \frac{f^y_b}{\rho_b} Y(x - x_b, y-y_b, h_b),
\end{eqnarray}
giving a vector map which is also integrated along the line of
sight.

\subsubsection{Cross sections of 3D data}
 A cross section can be taken of SPH data by summing the
contributions to each pixel in the cross section plane from all particles within
$2h$ of the plane. In
the implementation used in SUPERSPHPLOT the cross section is always at a fixed value of the third co-ordinate
(ie. for xy plots the cross section is in the z direction). Oblique cross
sections can be taken by rotating the particles first. Vector cross sections are taken by
interpolating each component separately.

 Note that the cross section position can be moved up (towards the observer) or down (away from the
 observer) through the data interactively using
the 'd' (for down) and 'u' (for up) keys in interactive mode.

\begin{figure}
\begin{center}
\epsfig{file=xsec3D.eps,width=0.5\textwidth}
\caption{Computation of a two dimensional cross section through 3D data}
\label{fig:xsec3D}
\end{center}
\end{figure}

\paragraph{Flythru}
 With the cross section option chosen in 3D, a flythru may be chosen at the plotting prompt. This
plots multiple slices through the data.


\subsubsection{3D surface rendering of SPH data}
 This option is introduced in version 1.5 of SUPERSPHPLOT. The idea is to produce a visualisation of
the surface of a data set by performing a ray-trace through the SPH particles, with the density
distribution giving the optical depth and the rendered quantity providing the colour. Thus
low-density regions will be transparent whilst high density regions will be `optically thick' and
therefore opaque. 

For a homogeneous medium the transport equation for a ray traced from $0\to D$ is
\begin{equation}
I_\nu(D) = I_\nu(0) e^{-\tau_\nu (D)} + S_\nu(1 - e^{-\tau_\nu(D)}),
\label{eq:transport}
\end{equation}
where $I_\nu$ is the (frequency dependent) intensity, $S_\nu$ is the source function along the ray
and $\tau$ is the monochromatic optical depth. The first term in (\ref{eq:transport}) represents absorption (ie.
intensity decreases by $e^{-\tau}$ whilst the second term represents emission. For example, at large
optical depth ($\tau\to\infty$) everything is obscured and all we see is the source function (ie.
light emitted from D), whereas at low optical depth $\tau\to 0$ the source function contributes
nothing and all we see is the previous intensity $I(0)$.

The optical depth $\tau$ is given by
\begin{equation}
\tau(D) = \int \kappa \rho {\rm ds},
\end{equation}
where $\rho$ is the density and $\kappa$ is the opacity (with dimensions of ``cross section per unit
mass").

 For SPH visualisation the procedure is as follows. First of all we sort the particles in `z' (where
$z$ represents the distance from the observer to the particle. Then starting from the furthest
particles, we consider the attenuation of a ray through each particle. Since what we are after is a
final 2D pixel map, what we do in practise is take one ray for each pixel, but rather than taking a
ray at a time (and looping over particles), we loop over all of the particles (from back to front),
calculating the contribution of that particle to all rays (`pixels') in the final pixel map. The
optical depth through the particle is given by
\begin{equation}
\tau(x,y) = \kappa \int \rho {\rm dz},
\end{equation}
where we have assumed that the opacity $\kappa$ is independent of $z$. Using the SPH summation for
the density, we have
\begin{equation}
\tau(x,y) = \kappa \sum_b m_b \int W(\vert {\bf r} - {\bf r}_b \vert,h) {\rm dz},
\label{eq:tauxy}
\end{equation}
giving just a summation involving the SPH kernel integrated through one spatial dimension, which is
the same as is used in the 3D projections (see $\ref{sec:proj}$ for details of how we compute this).
All that remains is to adjust $\kappa$ appropriately to give the desired surface position. In
SUPERSPHPLOT an approximate value for $\kappa$ is computed according to
\begin{equation}
\kappa = \frac{\pi \bar{h}^2 }{ (\bar{m}Y(0) d)}
\end{equation} 
where $\bar{h}$ and $\bar{m}$ are estimates for the average smoothing length and particle mass, calculated from the current (fixed) plot limits according to $\bar{h} = 0.5*(h_{min} + h_{max})$
(similarly for $\bar{m}$ - the important aspect here is that these values do not change between dump
files) and $Y(0)$ is the value of the integrated kernel function
(\S\ref{sec:proj})at the origin. The dimensionless parameter $d$ is then a user defined value giving
approximately the surface depth in terms of ``number of smoothing lengths".


 Actually, we rather than computing the sum $\ref{eq:tauxy}$ for the whole ray, we consider just the
attenuation of the ray through one particle at a time, using the optical depth for that particle alone.
Looping over each particle, we calculate the contribution to all rays within the kernel radius $2h$. That
is we have, for each particle
\begin{equation}
I(x,y,in front of particle) = I(x,y,behind particle) e^{-\tau_i(x,y)} + S_i(1 - e^{-\tau_i(x,y)}),
\label{eq:transportp}
\end{equation} 
where $S_i$ is the source function (discussed below) and the optical depth through the particle's reach is
\begin{equation}
\tau_i (x,y) = \kappa m_i Y(x-x_i,y-y_i,h),
\end{equation}
where $Y$ is the integrated kernel function as in \S\ref{sec:proj}.

 
 In the computation of the surface rendering, there are two ways of proceeding. The first option is to assign each
particle an actual red, green and blue colour corresponding to the particle's value of the rendered
quantity (ie. from the colour table). The source function then consists of a red, green and blue
intensity $S_{i(r)},S_{i(g)},S_{i(b)}$. Then we would add up [ie. using (\ref{eq:transportp})] the intensities in each colour (red, green and blue) to get final red, green and blue values at each pixel. The effect of this is to ``blend" colours (so a red plus blue would make
purple), which is more like what happens in a real gas, but is meaningless in the sense that the
colours produced may no longer correspond to those in the colour table.

 
 The alternative is to use a `monochromatic' intensity - that is where the source function $S_i$ for each
particle is just the value of the rendered quantity at the particle location. Alongside this a
`total' optical depth is computed along each ray. Again, we add up the
intensities according to (\ref{eq:transport}), but now there is only a single value of $I$ for each
pixel, which corresponds to a final ``ray-averaged" value of the rendered quantity. The pixel map can
then be rendered in the usual manner using the ray-averaged values (which represent the values of the
rendered quantity at the `last scattering surface'). The only complication here is that we must make
the particles optically thin to the background. Thus the final colours must be faded to the
background colour (ie. black) according to the total optical depth computed for each pixel.


 The latter method is the one used in SUPERSPHPLOT. The one caveat is that, because
it means using more than 256 colours (for example, if we have a colour map with 256 colours, we
need to then have all 256 colours at varying levels of intensity), at present this is implemented by
writing the pixel map directly to a .ppm file (called supersphplot\_\#\#\#\#\#.dat where the number
is the number of the current dumpfile) and the approximate version (ie. without the background fade)
is given to the PGPLOT device (e.g. the /xw screen). The .ppm files can be converted easily to any
other format (e.g. png, ps) using netpbm tools (\url{http://netpbm.sourceforge.net/}) such as
ppmtopng, ppmtops.

 For examples of the 3D surface rendering in SUPERSPHPLOT, have a look at my movies of neutron star mergers at \url{http://www.astro.ex.ac.uk/people/dprice/research/nsmag}.

\subsection{Rotation \& 3D perspective}
\subsubsection{Rotation}
 An angle of rotation about may be set each axis may be set in the x)sec/rotate submenu or
interactively (press 'h' in interactive mode to see the exact keystrokes). Rotations are performed in the
order $z-y-x$. This means that the $y-$ rotation angle is an angle about the \emph{new} $y-$axis, defined
by the $z$ rotation and similarly for the $x-$ rotation. If you think about it long enough, it makes
sense. If in doubt, do it interactively and set the angles in the order $z-y-x$.

 Rotated axes or boxes can be plotted using the rotation options in the x)sec/rotate submenu. A
different origin can also be set from the rotation options in this menu.

\subsubsection{3D perspective}
 3D perspective (turned on/off in the xsec/rotate menu) is defined by two parameters: a distance to the observer (which we will call $zobs$) and a distance
between the observer and a screen placed in front of the observer (which we will call $dscreen$).
The transformation from usual $x$ and $y$ to screen $x'$ and $y'$ is then given by
\begin{eqnarray}
x' & = & x*dscreen/(zobs-z), \nonumber \\
y' & = & y*dscreen/(zobs-z).
\end{eqnarray}
 This means that objects at the screen distance will have unit magnification, objects closer than the
screen will appear larger (points diverge) and objects further away will appear smaller (points
converge)\footnote{Objects in the mirror may be closer than they appear}. The situation could be
beautifully illustrated if I could be bothered drawing a figure. I have found reasonable
results with something like a $1/10$ reduction at the typical distance of the object (ie.
observer is placed at a distance of $10\times$ object size with distance to screen of $1\times$ object
size. SUPERSPHPLOT sets this as default using the z plot limit as the `object size'.

\subsection{Power spectrums (1D only)}
 In one dimension an extra plot item appears
in the data menu which takes a power spectrum (in space) of a particular
variable defined on the particles. Upon selection the user is prompted for
various settings before plotting the power spectrum. For data defined on
irregularly distributed particles, there are two methods for taking the power
spectrum: Either to interpolate to an even grid and use a Fourier
transform or to use a method for calculating a periodogram of
irregularly sampled data which can have significant advantages over
interpolation. Algorithms for both of these methods have been
implemented. For the first, the SPH data is interpolated to a one dimensional
grid using the kernel via the \verb+interpolate1D+ subroutine before calculating the (slow!) fourier
transform in \verb+powerspectrum_fourier+. For the second, an algorithm due to
Lomb and \citet{scargle81} described in \citet{numericalrecipes} is
used\footnote{Note that the subroutines given in \citet{numericalrecipes} have
\emph{not} been used as they are not free software.},
located in the subroutine \verb+powerspectrum_lomb+. The actual plotting is done
in the subroutine \verb+plot_powerspectrum+. An example of this feature is shown
in Figure~\ref{fig:powerspectrum_lomb}, where a power spectrum of a given
spectral index has been defined on the particles as an initial condition. The
plot shows the velocity variable given the initial power spectrum and the power
spectrum calculated via the Lomb periodogram.
\begin{figure}
\centering

\caption{Example of one dimensional power spectrum using the Lomb periodogram}
\label{fig:powerspectrum_lomb}
\end{figure}

 It should be stressed, however, that \emph{neither} of the subroutines for
calculating the power spectrum is particularly fast and have \emph{only} been included as a preliminary feature
since I have used them once or twice in one dimensional simulations where speed
is not an issue. The algorithms are fairly simple to extend to multidimensional
data, although faster implementations would be needed (such as a Fast
Fourier Transform routine).


\section{Other features}


\subsection{Plot titles}
\label{sec:title}
 Plots may be titled individually by creating a file called \verb+titlelist+ in
the current directory, with the title on each line corresponding to the position
of the plot on the page. Thus the title is the same between timesteps unless the
steps are plotted together on the same physical page. Leave blank lines for
plots without titles. For example, creating a file called \verb+titlelist+ in
the current directory, containing the text:
\begin{verbatim}
plot one
plot two
plot three
\end{verbatim}
and positioning the title using the default options, produces the titles shown
on the graph in Figure~\ref{fig:titleexample} (where there are 6 plots on the physical page).

%%\begin{figure}
%\centering
%
%\caption{Example use of plot titles}
%\label{fig:titleexample}
%\end{figure}

\subsection{Plot legends}
\label{sec:legend}
 The text (e.g. `\verb+t=+') used in the legend can be changed via
the legend options in the (p)age submenu. The numerical value is taken from the \verb+time+ array
in the data read.


\section{FAQS: How do I...}

\subsection{Read/process my data into images without having to answer prompts?}
 Firstly edit the settings in the \verb+defaults+ file in the current
directory (created by doing a `save defaults' from the main menu) before invoking SUPERSPHPLOT.

 Having edited the defaults file, the simplest way of running SUPERSPHPLOT
non-interactively is to write a small shell script which runs SUPERSPHPLOT
and answers the prompts appropriately. Something like the following should work:
\begin{verbatim}
#!/usr/bin/tcsh
cd plot
supersphplot myrun* << ENDINPUT
2
1
8
0
mypostcript.ps/ps
q
ENDINPUT
\end{verbatim}
which would plot the data in columns 2 and 1 and render the data in column 8 with
output to file \verb+mypostscript.ps+.

\subsection{Calculate additional quantities?}
 Additional quantities are calculated in the subroutine \verb+calc_quantities+,
in which it should be a simple matter to add your own.
If the calculated quantity is to be used elsewhere (for example in an exact
solution), an indicator should be created for its position in the data array
(e.g. the integer variable \verb+ih+ refers to the position of the smoothing
length in the data array). It is also preferable to indicate those quantities
from which the new quantity is calculated, so that no error will occur if they
are not present.

\subsection{What about boundaries? How does the rendering work near a boundary?}
 Usual practise in SPH simulations near boundaries is
to introduce ghost particles which mirror the real particles. SUPERSPHPLOT does not
explicitly setup any ghost particles but will use any that are present in the data
(specified using \verb+labeltype = 'ghost'+ in the \verb+read_data+ subroutine and
then specifying the number of particles of this type). Ghost particles contribute
to the rendering calculations but not to the determination of the plot limits. Note,
however, that SUPERSPHPLOT does \emph{not} set up ghost particles itself, as this may depend
on the type and location of the boundary. Thus if your simulation uses ghost particle
boundaries, the ghost particles should be dumped alongside the gas particles in the
output file so that their positions, masses, densities and smoothing lengths can be
read into SUPERSPHPLOT and used to render the image appropriately.

\subsection{Use special characters in the plot labels?}
 Several of the examples shown in this manual use special characters (such as
the $\int$ character) in the plot labels. The PGPLOT user guide explains how to do
this, but the basic idea is that PGPLOT uses escape sequences to plot special
characters. For example to plot the greek letter $\rho$ we would use
\begin{verbatim}
label = 'this would print the greek letter \gr'
\end{verbatim}
where \verb+\gr+ is the PGPLOT escape sequence for $\rho$. For other
characters the escape sequence is given by a number. For example for the integral 
\begin{equation}
\int v_x \mathrm{dx}
\end{equation}
we would use
\begin{verbatim}
label = '\(2268) v\d x \u dx'
\end{verbatim}
where \verb+\(2268)+ is the escape sequence for the integral sign. The
\verb+\d+ indicates that what follows should be printed as subscript and
\verb+\u+ correspondingly indicates a return to normal script (or from normal script to
superscript). All of the escape sequences for special characters are listed in
the appendix to the PGPLOT user guide.
\begin{quote}
 WARNING: Note that the use of escape characters can be compiler dependent and
 may not therefore work on all compilers (for example the intel compiler needs
 the -nbs flag).
\end{quote}

\subsection{Make movies?}
 At the PGPLOT device prompt
\begin{verbatim}
Graphics device/type (? to see list, default /xwin):
\end{verbatim}
choose \verb+/gif+ or \verb+/vgif+ (some installations of PGPLOT may also have \verb+/png+
installed). The images will then be written as \verb+.gif+ files which can then be easily compiled
together to form an animation. Under unix the \verb+gifmerge+ command (if installed) is a simple way
of making a single animated gif file out of a series of gif images. Animated gifs are robust but
require large amounts of memory to run at any reasonable speed. However many software packages exist
for converting animated gifs into other, more compressed formats (such as the windows .avi format or
under unix the .fli format). One such package is the
\verb+convert+ command included as part of the GIMP (Gnu Image Manipulation Package) toolkit.
For presentations the windows .avi format is a good choice, although codecs for conversion are a
little harder to come by. Under windows the commercially available \verb+videomach+ program is one
such tool as well as several Microsoft products.

 Another tool under unix is the \verb+fbm2fli+ package, which will take a series of .gif or .png files and
convert them into a .fli animation (which can be played, for example by the \verb+xanim+ tool). This
format is great for animations of simulations but as yet does not import into powerpoint and the like.

\section{User contributions / Wishlist for future improvements}
 Please contribute!! Any user contributions and/or suggestions would be greatly
appreciated. The following in particular would be very useful:

\begin{itemize}
\item Exact solutions for your favourite test problem(s). It would be great to
build a library of user-contributed exact solutions.
\item Data analysis tools (e.g. fourier transforms / statistical analysis /
algorithms for finding binary stars etc) which could be incorporated.
\item New visualisation techniques (e.g. an isosurfacing routine for SPH, better
vortex line tracing).
\item More colour schemes (see \verb+colours.f90+ for how to do this)
\item Pretty pictures! If you happen to plot some of your data and spend the
next several minutes marvelling at how astoundingly beautiful it all looks, please send
me a copy (either ps, gif or a movie) to add to the gallery and a few lines
describing the simulation.
\end{itemize}


If you wish to send me subroutines or snippets of (Fortran only!) code for doing any of the above or
more, please also send me a \LaTeX file
documenting the subroutine similar to the documentation given in this user guide.
Also, please, please comment your code clearly so that others can figure out
what it does and try to catch as many errors as possible so that the whole
program is robust.  One thing I have avoided doing is to use any SPH
routines which explicitly require finding neighbours, to avoid introducing treecodes and
the like and to keep the program independent of any particular implementation of
SPH. An example of a
routine would be to find the div/curl of a vector quantity using
the SPH summation.

Contributions, comments and inevitable bug fixes
should be sent to:
\begin{verbatim}
dprice@astro.ex.ac.uk
\end{verbatim}
although check that this email address is current because I am still a postdoc!

\section*{Acknowledgements}
 Several of the routines were developed from ideas used by Matthew Bate. The
polytrope exact solution is from a routine by Joe Monaghan. I am indebted to one
Thomas S. Ullrich at the University of Heidelberg who wrote the prompting module
which is used throughout the program.

\newpage
\appendix

\section{Source code overview}
Here is a brief description of all the files making up the code:
\begin{longtable}{|lp{0.7\textwidth}|}
\hline
Filename & Description \\
\hline \endhead
\multicolumn{2}{|r|}{\emph{continued on next page}} \\
\hline \endfoot
\hline \endlastfoot
     allocate.f90           & allocates memory for main arrays \\
     calc\_quantities.f90    & calculates additional quantities from particle data \\
     colours.f90            & colour schemes for rendering\\
     colourparts.f90	 & colours particles\\
     danpgsch.f           & sets character height independent of page size\\
     danpgtile.f          & my utility for tiling plots on the pgplot page\\
     danpgwedg.f          & my very minor modification of pgwedg\\
     defaults.f90           & writes/reads default options to/from file\\
     exact.f90              & module handling exact solution settings\\
     exact\_densityprofiles.f90 & various $N-$body density profiles \\
     exact\_fromfile.f90     & reads an exact solution tabulated in a file\\
     exact\_mhdshock.f90     & some tabulated solutions for mhd shocks\\ 
     exact\_polytrope.f90    & exact solution for a polytrope\\
     exact\_rhoh.f90	 & exact relation between density and smoothing length\\
     exact\_sedov.f90        & exact solution for sedov blast wave\\
     exact\_shock.f90        & exact solution for hydrodynamic shocks\\
     exact\_wave.f90         & exact solution for a propagating sine wave\\
     exact\_toystar.f90      & exact solution for the toy star problem\\
     exact\_toystar2D.f90    & exact solution for the 2D toy star problem\\
     get\_data.f90           & wrapper for main data read\\
     geometry.f90           & module handling different coordinate systems\\
     globaldata.f90         & various modules containing "global" variables\\
     interactive.f90        & drives interactive mode\\
     interpolate1D.f90	 & interpolation of 1D SPH data to grid using kernel\\
     interpolate2D.f90	 & interpolation of 2D SPH data to grid     \\
     interpolate3D\_xsec.f90 & 3D cross section interpolations\\
     interpolate3D\_projection.f90	 & 3D interpolation integrated through domain\\
     legends.f90		       & plots (time) legend on plot\\
     limits.f90                   & sets initial plot limits and writes to/reads from limits file\\
     menu.f90               & main menu\\
     options\_data.f90       & sets options relating to current data\\
     options\_limits.f90     & sets options relating to plot limits\\
     options\_page.f90       & sets options relating to page setup\\
     options\_particleplots.f90 & sets options relating to particle plots\\
     options\_powerspec.f90  & sets options for power spectrum plotting\\
     options\_render.f90	 & sets options for render plots\\
     options\_vector.f90	 & sets options for vector plots\\
     options\_xsecrotate.f90 & sets options for cross sections and rotation\\
     particleplot.f90       & subroutines for particle plotting\\
     plotstep.f90           & main subroutines which drive plotting of a single timestep\\
     powerspectrums.f90     & calculates power spectrum of 1D data (2 methods)\\
     read\_data\_dansph.f90   & reads data from my format of data files\\
     read\_data\_mbate.f90    & reads data from matthew bate's format of data files\\
     read\_data\_xxx.f90 & reads data from \ldots \\ 
     render.f90	 	 & takes array of pixels and plots render map/contours etc\\
     rotate.f90             & subroutines controlling rotation of particles\\
     setpage.f90            & sets up the PGPLOT page (replaces call to PGENV/PGLAB)\\
     supersphplot.f90	 & main program, drives menu loop\\
     timestepping.f90       & controls stepping through timesteps\\
     titles.f90        & reads a list of titles to be used to label each timestep\\
     transform.f90	 	 & applies various transformations to data (log10, 1/x, etc) \\
\end{longtable}

\section{Exact solution details}
\label{sec:exact}
\subsection{Errors}
The error norms calculated when exact solutions are plotted are as follows: The
error for each particle is given by
\begin{equation}
e_i = f_i - f_{exact},
\end{equation}
where the exact solution $f_{exact}(x)$ is the solution returned from the exact
solution subroutines (with resolution adjustable in the exact solution options menu
option) interpolated to the position of the current particle $x_i$ via a simple linear
interpolation. The absolute $L_1$ error norm is simply the average of the errors across
the domain, calculated according to
\begin{equation}
\Vert e \Vert_{L_1} = \frac{1}{N f_{max}} \sum_{i=1}^N \vert e_i \vert,
\end{equation}
where $f_{max}$ is the maximum value of the exact solution in the region in which the
particles lie (also only particles in the current plot are used) which is used to
normalise the error estimate. A better error norm is the $L_2$ or \emph{Root Mean Square}
 (RMS) norm given by
\begin{equation}
\Vert e \Vert_{L_2} = \left[\frac{1}{N} \left( \frac{1}{f_{max}} \sum_{i=1}^N \vert e_i
\vert^2 \right)\right]^{1/2}.
\end{equation}
Finally the maximum error, or $L_\infty$ norm is calculated according to
\begin{equation}
\Vert e \Vert_{L_\infty} = \frac{1}{f_{max}} {\rm max}_i \vert e_i \vert.
\end{equation}
which is the most stringent error norm.

 The inset plot of the individual particle errors shows the fractional deviation for
 each particle given by
\begin{equation}
e_{i,frac} = (f_i - f_{exact}) / f_{exact}.
\end{equation}

\subsection{Shock tubes (Riemann problem)}
 The subroutine \verb+exact_shock+ plots the exact solution for a one-dimensional shock tube
(Riemann problem). The difficult bit of the problem is to determine the jump in
pressure and velocity across the shock front given the initial left and right
states. This is performed in a separate subroutine (riemannsolver) as there are 
many different methods by which this can be done (see e.g. \citealt{toro92}). 
The actual subroutine exact\_shock reconstructs the shock profile (consisting of
a rarefaction fan, contact discontinuity and shock, summarised in Figure
\ref{fig:shocktube}), given the post-shock values of pressure and
velocity. 

 The speed at which the shock travels into the `right' fluid can be computed from the post shock
velocity using the relation
\begin{equation}
v_{shock} = v_{post}\frac{(\rho_{post}/\rho_R)}{(\rho_{post}/\rho_R)- 1},
\end{equation}
where the jump conditions imply
\begin{equation}
\frac{\rho_{post}}{\rho_R} = \frac{(P_{post}/P_R) + \beta}{1 + \beta (P_{post}/P_R)}
\end{equation}
with
\begin{equation}
\beta = \frac{\gamma - 1}{\gamma + 1}.
\end{equation}

\subsubsection{Riemann solver}
 The algorithm for determining the post-shock velocity and pressure is taken
from \citet{toro92}.

\subsection{Polytrope}
 The subroutine \verb+exact_polytrope+ computes the exact solution for a static polytrope with
arbitrary $\gamma$. From Poisson's equation
\begin{equation}
\nabla^2 \phi = 4\pi G \rho,
\end{equation}
assuming only radial dependence this is given by
\begin{equation}
\frac{1}{r^{2}} \frac{d}{dr} \left(r^{2} \frac{d\phi}{dr} \right) = 4\pi G \rho(r).
\label{eq:poissonsph}
\end{equation}
  
  The momentum equation assuming an equilibrium state (${\bf v} = 0$) and a
polytropic equation of state $P = K\rho^{\gamma}$ gives
\begin{equation}
\frac{d\phi}{dr} = - \frac{\gamma K}{\gamma-1}\frac{d}{dr} \left[\rho^{(\gamma -1)} \right]
\label{eq:polyk}
\end{equation}
Combining (\ref{eq:poissonsph}) and (\ref{eq:polyk}) we obtain an equation for the density profile
\begin{equation}
\frac{\gamma K}{4\pi G (\gamma - 1)} \frac{1}{r^{2}} \frac{d}{dr} \left[r^{2}
\frac{d}{dr}\left( \rho^{\gamma-1} \right) \right] + \rho(r) = 0.
\label{eq:dens}
\end{equation}
This equation can be rearranged to give
\begin{equation}
\frac{\gamma K}{4\pi G (\gamma - 1)} \frac{d^2}{dr^2}
\left[r\rho^{\gamma-1}\right] + r\rho = 0.
\end{equation}
 The program solves this equation numerically by defining a variable
\begin{equation}
\mathcal{E} = r \rho^{\gamma-1}
\end{equation}
and finite differencing the equation according to
\begin{equation}
\frac{\mathcal{E}^{i+1} - \mathcal{E}^i + \mathcal{E}^{i-1}}{(\Delta r)^2} =
\frac{4\pi G (\gamma - 1)}{\gamma K} r
\left(\frac{\mathcal{E}}{r}\right)^{1/(\gamma-1)}.
\end{equation}

\subsection{Linear wave}
 The subroutine \verb+exact_wave+ simply plots a sine function on a given graph.
 The function is of the form
\begin{equation}
y = \sin{(k x - \omega t)}
\end{equation}
where $k$ is the wavenumber and $\omega$ is the angular frequency. These
parameters are set via the input values of wavelength $\lambda = 2\pi/k$ and
wave period $P = 2\pi/\omega$.

\begin{table}
\centering
\begin{tabular}{|l|l|}
\hline
$\lambda$ & wavelength \\
$P$ & period \\
\hline
\end{tabular}
\caption{Input parameters for the linear wave exact solution}
\end{table}

\subsection{Sedov blast wave}
 The subroutine \verb+exact_sedov+ computes the self-similar Sedov solution for a blast wave.

\subsection{Toy stars}
 The subroutine \verb+exact_toystar1D+ computes the exact solutions for the `Toy
Stars' described in \citet{mp04}. The system is one dimensional with velocity $v$, density $\rho$, and pressure
$P$. The acceleration equation is 
\begin{equation}
\frac{dv}{dt} = - \frac{1}{\rho} \frac{\partial P}{\partial x}  - \Omega^2 x,
\end{equation}
 We assume the equation of state is 
\begin{equation}
P = K \rho^\gamma,
\end{equation} 

 The exact solutions provided assume the equations are scaled such that
$\Omega^2 = 1$.
 
\subsubsection{Static structure}
The static structure is given by
\begin{equation}
\bar \rho = 1- x^2,
\end{equation}

\subsubsection{Linear solutions}
The linear solution for the velocity is given by
\begin{equation}
v = 0.05 C_s G_n(x) \cos{\omega t} )
\end{equation}
density is
\begin{equation}
\rho = \bar{\rho} + \eta
\end{equation}
where 
\begin{equation}
\eta = 0.1 C_s \omega P_{n+1}(x) \sin{(\omega t)})
\end{equation}

\subsubsection{Non-linear solution}
In this case the velocity is given by
\begin{equation}
v = A(t) x,
\end{equation}
whilst the density solution is
\begin{equation}
\rho^{\gamma -1} = H(t) - C(t) x^2.
\end{equation}
where the parameters A, H and C are determined by solving the ordinary
differential equations
\begin{eqnarray}
\dot{H} & = & -AH(\gamma -1), \\
\dot{A} & = & \frac{2K \gamma}{\gamma -1} C - 1 - A^2 \\
\dot{C} & = & -AC(1+ \gamma),
\end{eqnarray}
The relation
\begin{equation}
A^2 = -1 - \frac{2 \sigma C}{\gamma -1} + kC^{\frac{2}{\gamma +1}},
\label{eq:kconst}
\end{equation}
is used to check the quality of the solution of the differential equations by
evaluating the constant $k$ (which should remain close to its initial value).

\subsection{MHD shock tubes}
 These are some tabulated solutions for specific MHD shock tube problems at a
given time taken from the tables given in \citet{dw94} and \citet{rj95}.

\subsection{h vs $\rho$}
 The subroutine exact\_hrho simply plots the relation between smoothing length
and density, ie.
\begin{equation}
h = h_{fact} \left(\frac{m}{\rho}\right)^{1/\nu}
\end{equation}
where $\nu$ is the number of spatial dimensions. The parameter $h_{fact}$ is
output by the code into the header of each timestep. For particles of different
masses, a different curve is plotted for each different mass value.

\newpage

\section{Writing your own read\_data subroutine}
\label{sec:writeyourown}
The first \verb+ndim+ columns in the main data array \emph{must} contain the particle co-ordinates.
After these columns the ordering of data is not important, although vector quantities should
always be listed with components in the correct order (e.g. $(\nabla\times {\bf v})_x$,
followed by the $y-$ and $z-$ components) for both vector plotting and for the
correct co-ordinate transformation of the vector quantities. Note that the co-ordinates and velocities can have different
numbers of dimensions (specified by \verb+ndim+ and \verb+ndimV+) since this can occur, for example, in MHD simulations.

Most important is that, for the rendering routines to work, the density, particle
masses and smoothing lengths for \emph{all} of the (gas) particles \emph{must} be read in from
the data file and their locations in the main data array labelled using the integer
parameters \verb+irho+, \verb+ipmass+ and \verb+ih+. Labelling of the location of other particle
quantities (e.g. \verb+iutherm+ for the thermal energy) is used in
order to plot the exact solutions on the appropriate graphs and also for calculating
additional quantities (e.g. calculation of the pressure uses \verb+iutherm+ and
\verb+irho+).

 The positions of vector components in the data columns are indicated by setting the variable \verb+iamvec+ of that
column equal to the first component of the vector of which this component is a part. So if column 4
is a vector quantity (say ${\bf v}$ in 3D), then \verb+iamvec(4) = 4+, \verb+iamvec(5) = 4+ and
\verb+iamvec(6) = 4+. Similarly the string \verb+labelvec+ should be set, ie. \verb+labelvec = 'v'+ for these columns.

\bibliographystyle{bibstyle}
\bibliography{sph,mhd}

\end{document}
